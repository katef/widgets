<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html [
	<!ENTITY ldquo "&#8220;">
	<!ENTITY rdquo "&#8221;">

	<!ENTITY kmkf.url.dl "http://kmkf.elide.org/releases">
]>

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>About</title>

		<meta name="description" content="About"/>
		<meta name="keywords"    content="about, rationale, introduction, intro, overview, download, checkout, source, svn, rcs, cvs, git, packages"/>
		<meta name="rcsid"       content="$Id: index.xhtml$"/>
	</head>

	<body>
		<p>These makefiles are an attempt to provide a general purpose
			build system suitable for use in various projects.
			This is the result of lessons learned from previous work,
			taking the ideas I liked and addressing the problems I found.</p>

		<p>For most BSD-like <filename>.mk</filename> systems, there's a
			&ldquo;you can only build one kind of thing per
			Makefile&rdquo; limitation.
			This is a side effect of using single variables as an interface
			for each <filename>.mk</filename> file, rather than lists.
			For example, in
			<filename>bsd.prog.mk</filename>,
			<filename>tendra.prog.mk</filename>,
			<filename>os161.prog.mk</filename>,
			<filename>cthru.prog.mk</filename> and others,
			only one <var>PROG</var> may be built.
			This goes hand in hand with executing make recursively,
			the problems for which are discussed
			by Peter Miller in <a href="http://aegis.sourceforge.net/auug97.pdf">Recursive
			Make Considered Harmful</a>.</p>

		<p>The typical solution for this is to arrange the source tree such
			that there is only one <filename>.mk</filename> thing per directory,
			which is usually a good idea, but gets in the way for some situations.
			Alternately to execute separate instances of make for each
			&ldquo;sub&rdquo; thing, which worsens the downsides of recursive make.
			I don't think either of these are show-stopping flaws
			(indeed large codebases such as the BSD trees seem to get the job done
			without too much fuss), but I do think they are indicative of taking
			a fundamentally wrong approach and then trying to patch that up post-hoc.</p>

		<p>My aims were:</p>

		<ul class="goals">
			<li>To provide separate <filename>.mk</filename> files for each type of thing.
				Different projects need different things.</li>

			<li>Not to have too many targets.<!--
				(<a href="http://www.gnu.org/software/automake/">Automake</a> is nuts.
				BSD's <filename>.mk</filename> files are less nuts, but still nuts.)
			--></li>

			<li>Use list variables as interfaces, allowing multiple items.</li>

			<li>Non-recursive; one top-level Makefile which includes all rules.
				A side-effect is that <code>.include</code> guards are unneccessary.</li>

			<li>Entry point at any directory.</li>

			<li>Handle dependencies correctly!
				It's surprising how many things get tricky bits wrong.</li>

			<li>Convenient to package:
				Put all the overridable settings in one place, so it's easy to see.
				Build to a seperate directory; this allows for a read-only source tree.
				Install to a staging directory.</li>
		</ul>

		<p>Generally I feel these goals have been met, and so I'm making
		these .mk files available for general use, and converting all my
		projects to use them.</p>

		<p>Although the current <filename>.mk</filename> files only provide
			for the minimum required for a proof of concept system&mdash;for example,
			only C source is supported&mdash;the structure and arrangement
			of interfaces is in place and this may be extended to provide for
			a wider variety of things without any fundamental change.</p>

		<p>See <a href="/kmkf.7mk/"><span class="command" data-manvolnum="7mk">kmkf</span></a> for more.</p>

<!--
		<p>I'm using bmake because I prefer it to GNU make.
			subset of bmake dialects (sjg's bmake, *BSD make(1), etc)
			not portable make because it's unrealistic.
			The dialect of make(1) is not intrinsic to the approach I've taken;
			you could implement the same idea for GNU make instead.</p>

		<p>fundamental implementation idea:
		xyz:: targets appended to by various .mk files
		top-level user makefile which brings in each .mk file, and glues them together with
		rules for the user's source tree</p>

		<p>i decided to re-use variables between makefiles (CLEAN, LIB etc) rather than naming a distinct one per .mk file. this allows "chaining together" of makefiles, as per cherrybuild.
		While this suited cherrybuild's BSD-like approach, in practice however I think it's of limited value,
		and targets' dependencies make a better vehicle for communicating lists between .mk files.
		</p>
-->
	</body>
</html>

