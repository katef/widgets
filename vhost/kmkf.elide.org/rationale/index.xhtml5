<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html [
	<!ENTITY make "make">
]>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>Rationale</title>
	</head>

	<body>
		<p>These makefiles are an attempt to provide a general purpose
			build system suitable for use in various projects.
			This is the result of lessons learned from previous work,
			taking experience from:</p>

		<p>wanted to make something that's: be reusable between all my projects.
			in particular, practical for the typical kind of things i write
			(source split into various directories,
			a couple of binaries, a library or two, and some documentation)</p>

<!--
		<p>result of lessons learned from previous work:</p>

		<dl>
			<dt>CherryBuild (<a href="http://www.bubblephone.com/">Bubblephone Ltd.</a>)</dt>
			<dd>
				<p>Makefiles written by my colleague Cherry, for our code at work.
					He's a NetBSD developer, and these were largely inspired by
					the BSD Makefiles.
					It handles dependencies by running <code>cc -MD</code>,
					executes <code>${MAKE}</code> recursively,
					and groups functionality into seperate <filename>.mk</filename> files.</p>

				<p>We added a few concepts based on what we found convenient,
					such as the idea of &ldquo;chaining&rdquo;
					<filename>.mk</filename> files together by way of list variables.
					Each file documents what it &ldquo;expects&rdquo; and
					&ldquo;provides&rdquo;.</p>

				<p>One major shortcoming is that each <filename>.mk</filename> file
					only provides a single iterface.
					For example, if <filename>cthru.lex.mk</filename> is used to
					generate a lexer, only one <code>${LEX_GEN_C_FILE}</code> may
					be generated.
					If you need multiple lexers within one subdirectory, you're out of luck.
					To work around this, a facility for executing <code>${MAKE} -f ...</code>
					for &ldquo;multi-part&rdquo; Makefile.* files was added.
					This is obviously complex, and rather unelegant.
					KMKF addresses the same problem by using list variables.</p>
			</dd>

			<dt>The build system for <a href="http://www.tendra.org/">TenDRA</a></dt>
			<dd>
				<p>Building a compiler is complex.
					This was origionally some very simple makefiles glued together
					with a large shell script, and ported to one giant Makefile by
					asmodai and Eirik. Then reworked by Tobias, and finally split
					into multiple <filename>.mk</filename> files by myself,
					inspired by CherryBuild.</p>

				<p>What remains at the time of writing is very similar to CherryBuild.</p>
			</dd>

			<dt>ADT</dt>
			<dd>
				<p>An experiment in writing a portable subset of &make;.
					This targetted both GNU &make; and BSD dialects.</p>
			</dd>

			<dt>various ad-hoc stuff</dt>
			<dd>
				<p>Most of my projects started out as a single
					<filename>Makefile</filename> until they warranted
					evolving into something more complex.</p>
			</dd>

			<dt><a href="http://aegis.sourceforge.net/auug97.pdf">Recursive Make Considered Harmful</a> (Peter Miller)</dt>
			<dd>
				<p>gmake specific</p>
			</dd>
		</dl>
-->

		<p>my aims were:</p>
		<ul>
		<li>not too many targets (automake is nuts. BSD is less nuts but still nuts)</li>
		<li>solve the cherrybuild Makefile.multi hack (tendra also suffers this)</li>
		<li>non-recursive; one top-level makefile
			side-effect: no include guards</li>
		<li>seperate build directory
			effect: read-only source is possible</li>
		<li>entry point at any directory</li>
		<li>be convenient for packaging (install to a staging directory).
			in particular put all the overridable stuff in one place,
			so it's easily visible to someone making a package (top-level makefile)</li>
		</ul>

		<p>fundamental implementation idea:
		xyz:: targets appended to by various .mk files
		top-level user makefile which brings in each .mk file, and glues them together with
		rules for the user's source tree</p>

		<p>i decided to re-use variables between makefiles (CLEAN, LIB etc) rather than naming a distinct one per .mk file. this allows "chaining together" of makefiles, as per cherrybuild.
		While this suited cherrybuild's BSD-like approach, in practice however I think it's of limited value,
		and targets' dependencies make a better vehicle for communicating lists between .mk files.
		</p>

		<p>Generally I feel these goals have been met, and so i'm making
		these .mk files available for general use, and converting all my
		projects to use them.
		See <a href="/kmkf.5mk/"><span class="command" data-manvolnum="5mk">kmkf</span></a> for more.</p>

		<p>i'm using bmake because I prefer it to GNU make.
		subset of bmake dialects (sjg's bmake, *BSD make(1), etc)
		not portable make because it's unrealistic</p>

		<p>Although the current <filename>.mk</filename> files only provide
		for the minimum required for a proof of concept system&mdash;for example,
		only C source is supported&mdash;the structure and arrangement
		of interfaces is in place and this may be extended to provide for
		a wider variety of things without any fundamental change.</p>

		<p> similar things: dh's makefiles (except they are recursive)</p>
	</body>
</html>

