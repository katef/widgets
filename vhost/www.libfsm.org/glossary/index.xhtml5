<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html [
	<!ENTITY nfa "<abbr>NFA</abbr>">
	<!ENTITY dfa "<abbr>DFA</abbr>">
	<!ENTITY fsm "<abbr>FSM</abbr>">
]>

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Glossary</title>

		<meta name="description" content="TODO"/>
		<meta name="keywords"    content="TODO"/>
		<meta name="rcsid"       content="$Id: index.xhtml$"/>

		<link rel="stylesheet" href="../docs.css"/>
	</head>

	<nav id="sidebar">
<!-- TODO: xinclude these; centralise for all docs -->
		<h2>Manpages</h2>

		<table class="manpages">
			<col align="left"/>
			<col align="left"/>

			<tbody>
				<tr>
					<td><a href="http://man.libfsm.org/fsm.1/">fsm(1)</a></td>
					<td>Finite Automata <abbr>CLI</abbr></td>
				</tr>
				<tr>
					<td><a href="http://man.libfsm.org/re.1/">re(1)</a></td>
					<td>Regular Expressions <abbr>CLI</abbr></td>
				</tr>
				<tr>
					<td><a href="http://man.libfsm.org/lx.1/">lx(1)</a></td>
					<td>Lexer generator <abbr>CLI</abbr></td>
				</tr>

				<tr>
					<td><a href="http://libfsm.org/libre.3/">libre(3)</a></td>
					<td>libre <abbr>API</abbr> reference</td>
				</tr>
				<tr>
					<td><a href="http://libfsm.org/libfsm.3/">libfsm(3)</a></td>
					<td>libfsm <abbr>API</abbr> reference</td>
				</tr>
				<tr>
					<td><a href="http://libfsm.org/lx.3/">lx(3)</a></td>
					<td>lx generated <abbr>API</abbr> reference</td>
				</tr>

				<tr>
					<td><a href="http://libfsm.org/fsm.5/">fsm(5)</a></td>
					<td>fsm file format</td>
				</tr>
				<tr>
					<td><a href="http://libfsm.org/re.5/">re(5)</a></td>
					<td>libre regexp dialects</td>
				</tr>
				<tr>
					<td><a href="http://libfsm.org/lx.5/">lx(5)</a></td>
					<td>lx specification language</td>
				</tr>
			</tbody>
		</table>
	</nav>

	<body>
		<h2>Glossary</h2>

		<dl class="glossary">
			<dt id="D"><dfn>&dfa;</dfn></dt>
			<dd class="abbr">Deterministic Finite Automaton.</dd>
			<dd>
				<p>An automaton who's edge transitions are always unambiguous.
					Contrast to &nfa;.
					Hence for any given input, the next state is always
					immediately known.</p>

				<p>Every DFA has exactly one minimal form;
					libfsm provides <a href="TODO">fsm_minimize()</a> in
					<a href="TODO">&lt;fsm/graph.h&gt;</a> to produce this.</p>
			</dd>

			<dt id="E"><dfn>Epsilon</dfn></dt>
			<dd class="abbr">An &nfa; edge which may be
				traversed without consuming input.</dd>
			<dd>
				<p>These are particularly convenient for regular-expression
					style construction corresponding to Kleene operators,
					where repetition and optionality may be expressed simply
					by adding epsilon transitions which loop back or
					bypass a labelled edge.</p>

				<p>Epsilon edges may be created by calling
					<a href="TODO">fsm_addedge_epsilon()</a> in
					<a href="TODO">&lt;fsm/fsm.h&gt;</a>.</p>
			</dd>

			<dt id="F" class="alt"><dfn><abbr>FA</abbr></dfn></dt>
			<dt class="alt"><dfn><abbr>FSA</abbr></dfn></dt>
			<dt><dfn>&fsm;</dfn></dt>
			<dd class="abbr">Finite State Automata/Machine.</dd>
			<dd>
				<p>An automaton with a finite number of states.
					Transitions between the states correspond to input read,
					and are labelled with the input for each transition.
					By our use, the states themselves contain no information,
					other than possibly being an end state.</p>

				<p>According to <a href="TODO">[BC07]</a>,
					mathematically, an automaton is a pair
					<code class="texmath">A = (Q, E)</code>,
					where <code class="texmath">Q</code>&#xA0;is a finite set of states,
					and <code class="texmath">E</code>&#xA0;is a finite set
					of edges labelled by letters of a finite
					alphabet&#xA0;<code class="texmath">A</code>.
					Edges are triples of the form
					<code class="texmath">(p, a, q)</code>,
					where <code class="texmath">p, q \in Q, a \in A</code>.</p>

				<p>Wikipedia has <a rel="external" href="http://en.wikipedia.org/wiki/Finite_State_Machine">a particularly confusing explanation</a>.</p>

				<p>These are used all over computer science, in any situation
					where a program is in one of a set number of states,
					and input to that program causes it to change state.</p>
			</dd>

			<dt><dfn>&nfa;</dfn></dt>
			<dd class="abbr">Non-deterministic Finite Automaton.</dd>
			<dd>
				<p>An automaton who's edge transitions may include epsilon
					transitions, and may include multiple edges of the
					same label from any given state.
					Hence the edge to take for a given input is not known
					until further input is processed.</p>

				<p>For our purposes, we consider an &fsm; to be
					an &nfa; unless we know otherwise.
					<a href="TODO">fsm_isdfa()</a> in
					<a href="TODO">&lt;fsm/graph.h&gt;</a></p>

				<p>Any &nfa; may be converted to a &dfa;.
					libfsm provides <a href="TODO">fsm_todfa()</a> in
					<a href="TODO">&lt;fsm/graph.h&gt;</a> to convert an
					&nfa; to a &dfa;.</p>
			</dd>

			<dt id="R"><dfn>Regular</dfn></dt>
			<dd>
				<p>The class of languages which may be expressed as a &dfa;.</p>

				<p>A regular language is defined over an alphabet,
					<code class="texmath">\Sigma</code>:
					For each <code class="texmath">a \in \Sigma</code>,
					<code class="texmath">\{a\}</code> is regular.
					If&#xA0;<code class="texmath">A</code>
					and&#xA0;<code class="texmath">B</code> are regular,
					<code class="texmath">A \cup B</code> is regular,
					<code class="texmath">A \cdot B</code> is regular, and
					<code class="texmath">A^*</code> is regular.</p>

				<p>Hence a Regular Expression is an expression which denotes
					a Regular Language, and a Regular Language is the set of
					strings generated by that Regular Grammar.
					Regular Grammars are also known as <dfn>Type-3 Grammars</dfn>
					in the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky-Sch√ºtzenerger hierarchy</a>.</p>

				<p>Regular Expressions are typically notated using postfix
					operators, but need not be.</p>
			</dd>
		</dl>
	</body>
</html>

